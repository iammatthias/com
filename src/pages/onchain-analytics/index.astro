---
import Layout from "@layouts/layout.astro";
import Squiggle from "@components/squiggle.astro";
---

<Layout path='Onchain Analytics'>
  <main class='text'>
    <h1>Onchain Analytics</h1>
    <p>
      This site features onchain analytics to track sessions and page counts. If you're interested, you can read more
      about the project here: <a class='break' href='https://iammatthias.com/posts/1712329304675-onchain-hit-counter'
        >iammatthias.com/posts/1712329304675-onchain-hit-counter</a
      >.
    </p>
    <Squiggle />

    <h2>How it Works:</h2>
    <ul>
      <li>
        The client IP, user agent, and timestamp are hashed (keccak256) client-side to generate a unique, irreversible
        <code>sessionID</code>. Only the hash is stored.
      </li>
      <li><code>sessionID</code>s are stored onchain to validate page views without any personal data.</li>
      <li>Page views are counted using a simple incrementing integer attached to each page path.</li>
      <li>
        All onchain interactions are handled by a [syndicate.io](Syndicate.io) `Cloud Transaction` wallet in the
        background.
      </li>
    </ul>

    <h3>Meta Details</h3>
    <p>
      Data collection began at <a
        href='https://sepolia.basescan.org/tx/0x8364d0d8827f5129965955c0e836cb54af213dc0aaa43e7b53635f3ced43135f'
        >block number 8853154 on Base-Sepolia</a
      >. The contract is verified on BaseScan: <a
        class='break'
        href='https://sepolia.basescan.org/address/0x40d59f33d1e36d8ddc171af7c40bd85ca25008f0#code#L1'
        >0x40d59f33D1e36D8DDC171Af7C40Bd85Ca25008F0</a
      >.
    </p>

    <h3>The Data</h3>
    <p>There have been <span id='sessionCount'></span> unique sessions since the onchain analytics went live.</p>
    <p>Here are the top 5 pages, sorted by view count:</p>
    <table id='pageCounts'>
      <tr><th>Page</th><th>Views</th></tr>
      {
        Array.from({ length: 5 }).map((_, i) => (
          <tr>
            <td id={`page${i}`} />
            <td id={`views${i}`} />
          </tr>
        ))
      }
    </table>

    <h4>Portraits of Private Keys</h4>
    <p>
      Our on-chain analytics generates unique keccak256 hashes for each session, and these hashes can also serve as
      valid private keys. The keys are transformed into generative art by using their hexadecimal characters as
      pseudo-random values. It is essential to note that since the hashes are public, they should never be used as
      actual private keys in the wild.
    </p>
    <p>Click on a hash to view its corresponding portrait:</p>
    <div id='sessionIDs'>
      <!-- Placeholder for session IDs -->
      <div class='sessionPlaceholder'>Loading session IDs...</div>
    </div>
  </main>
</Layout>

<script>
  import { publicClient } from "@lib/viemClients";
  import { sessionCountABI, getAllPageViewsABI, getAllSessionHashesABI } from "@lib/abi";

  const contractAddress = await import.meta.env.PUBLIC_HIT_COUNTER_CONTRACT;

  updateData();

  document.addEventListener("astro:after-swap", async () => {
    console.log("Page loaded");
    await updateData();
  });

  const unwatch = setupBlockNumberWatcher();

  // Register cleanup function to be called on 'before-swap'
  document.addEventListener(
    "astro:before-swap",
    () => {
      // console.log("Cleaning up before navigation");
      unwatch(); // Correctly calling the cleanup function
    },
    { once: true }
  ); // Ensure this cleanup happens once per page load

  function setupBlockNumberWatcher() {
    return publicClient.watchBlockNumber({
      onBlockNumber: async () => {
        // console.log("Block number changed");
        await updateData();
      },
      onError: (error) => console.error("Error watching blocks:", error),
    });
  }

  async function updateData() {
    try {
      await Promise.all([updateSessionCount(), updatePageCounts(), updateSessionIDsIncrementally()]);
      return true; // Return true if successful
    } catch (error) {
      console.error("Error updating data:", error);
      return false; // Return false if there was an error
    }
  }

  function safelyUpdateTextContent(id, text) {
    const element = document.getElementById(id);
    if (element) {
      element.innerText = text;
      return true;
    }
    // console.error(`Element with id '${id}' not found.`);
    return false;
  }

  async function updateSessionCount() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: sessionCountABI,
        functionName: "sessionCount",
      });
      safelyUpdateTextContent("sessionCount", `${Number(data)}`);
    } catch (error) {
      console.error("Failed to fetch session count:", error);
    }
  }

  async function updatePageCounts() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllPageViewsABI,
        functionName: "getAllPageViews",
      });
      const pageData = data[0].map((page, index) => ({
        page: page,
        count: BigInt(data[1][index]),
      }));
      pageData.sort((a, b) => (a.count > b.count ? -1 : a.count < b.count ? 1 : 0));
      for (let item of pageData.slice(0, 5)) {
        safelyUpdateTextContent(`page${pageData.indexOf(item)}`, item.page);
        safelyUpdateTextContent(`views${pageData.indexOf(item)}`, item.count.toString());
      }
    } catch (error) {
      console.error("Failed to fetch page counts:", error);
    }
  }

  async function updateSessionIDsIncrementally() {
    const sessionIDs = document.getElementById("sessionIDs");
    if (!sessionIDs) {
      // console.error("Element with id 'sessionIDs' not found.");
      return;
    }
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllSessionHashesABI,
        functionName: "getAllSessionHashes",
      });

      sessionIDs.innerHTML = ""; // Clear previous entries
      const fragment = document.createDocumentFragment(); // Create a new fragment
      data.reverse().forEach((hash, index) => {
        const hashLink = document.createElement("a");
        hashLink.href = `/onchain-analytics/${hash}`;
        const hashSpan = document.createElement("span");
        hashSpan.className = "sessionHash";
        hashSpan.innerText = hash;
        hashLink.appendChild(hashSpan);
        fragment.appendChild(hashLink);
        fragment.appendChild(document.createTextNode(" "));

        // Append the fragment to the DOM in batches of 10 or at the end of the loop
        if ((index + 1) % 10 === 0 || index === data.length - 1) {
          sessionIDs.appendChild(fragment); // Append the fragment to the DOM
        }
      });
    } catch (error) {
      console.error("Failed to fetch session IDs:", error);
      sessionIDs.innerText = "Failed to fetch session IDs.";
    }
  }
</script>

<style>
  .text {
    font-size: var(--fs-sm);
  }

  .text th,
  .text td {
    font-family: monospace;
    font-size: 0.9rem;
  }

  .text td {
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
  }

  #sessionIDs {
    white-space: normal; /* Ensures the normal text wrapping and white-space handling */
  }
</style>

<style is:global>
  .sessionHash {
    font-family: monospace;
    display: inline; /* Keeps span inline */
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
    margin-right: 0.5rem; /* Adds horizontal space between items */
    transition:
      background-color 0.3s ease,
      color 0.3s ease; /* Smooth transition for background and text color */
  }

  .sessionHash:hover {
    background-color: var(--gold); /* Light grey background on hover */
  }

  .break {
    overflow-wrap: break-word; /* Handles normal wrapping */
    word-break: break-all; /* Forces break for long unbreakable strings */
  }
</style>
