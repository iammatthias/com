---
import Layout from "@layouts/layout.astro";
import Squiggle from "@components/squiggle.astro";
const CONTRACT_ADDRESS = import.meta.env.PUBLIC_ANALYTICS_CONTRACT;
---

<Layout path='Onchain Analytics'>
  <main class='text'>
    <h1>Onchain Analytics</h1>
    <p>
      This site features onchain analytics to track sessions and page counts. If you're interested, you can read more
      about the project here: <a class='break' href='https://iammatthias.com/posts/1712329304675-onchain-hit-counter'
        >iammatthias.com/posts/1712329304675-onchain-hit-counter</a
      >.
    </p>
    <Squiggle />

    <h2>How it Works:</h2>
    <ul>
      <li>
        The client IP, user agent, and timestamp are hashed (keccak256) client-side to generate a unique, irreversible
        <code>sessionID</code>. Only the hash is stored.
      </li>
      <li><code>sessionID</code>s are stored onchain to validate page views without any personal data.</li>
      <li>Page views are counted using a simple incrementing integer attached to each page path.</li>
      <li>
        All onchain interactions are handled by a [syndicate.io](Syndicate.io) <code>Cloud Transaction</code> wallet in the
        background.
      </li>
    </ul>

    <h3>Meta Details</h3>
    <p>
      Data collection began at block number <a
        href='https://sepolia.basescan.org/tx/0xc6fffb63218605b36b5cb7b07df1e66be77015e4ede9fe03b0356dd18d1fb8f8'
        >12315477</a
      > on Base-Sepolia, and the contract is <a href=`https://sepolia.basescan.org/address/${CONTRACT_ADDRESS}#code#L1`
        >verified on BaseScan</a
      >.
    </p>

    <h3>The Data</h3>
    <h4>Sessions</h4>
    <p>There have been <span id='sessionCount'></span> unique sessions since the onchain analytics went live.</p>
    <h4>Page Views</h4>
    <p>Top 5 pages</p>
    <table id='pageViewCounts'>
      <tr><th>Page</th><th>Views</th></tr>
      {
        Array.from({ length: 5 }).map((_, i) => (
          <tr>
            <td id={`page${i}`} />
            <td id={`views${i}`} />
          </tr>
        ))
      }
    </table>

    <h4>Events</h4>
    <p>Top events</p>
    <table id='eventCounts'>
      <tr><th>Event</th><th>Count</th></tr>
      {
        Array.from({ length: 3 }).map((_, i) => (
          <tr>
            <td id={`event${i}`} />
            <td id={`count${i}`} />
          </tr>
        ))
      }
    </table>

    <h4>Portraits of Private Keys</h4>
    <p>
      Our on-chain analytics generates unique keccak256 hashes for each session, and these hashes can also serve as
      valid private keys. The keys are transformed into generative art by using their hexadecimal characters as
      pseudo-random values. It is essential to note that since the hashes are public, they should never be used as
      actual private keys in the wild.
    </p>
    <p>Click on a hash to view its corresponding portrait:</p>
    <div id='sessionIDs'></div>
  </main>
</Layout>

<style>
  .text {
    font-size: var(--fs-sm);
  }

  .text th,
  .text td {
    font-family: monospace;
    font-size: 0.9rem;
  }

  .text td {
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
  }

  #sessionIDs {
    white-space: normal; /* Ensures the normal text wrapping and white-space handling */
  }
</style>

<style is:global>
  .sessionHash {
    font-family: monospace;
    display: inline; /* Keeps span inline */
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
    margin-right: 0.5rem; /* Adds horizontal space between items */
    transition:
      background-color 0.3s ease,
      color 0.3s ease; /* Smooth transition for background and text color */
  }

  .sessionHash:hover {
    background-color: var(--gold); /* Light grey background on hover */
  }

  .break {
    overflow-wrap: break-word; /* Handles normal wrapping */
    word-break: break-all; /* Forces break for long unbreakable strings */
  }
</style>

<script>
  import { getAllSessionIds, getSessionCount, getAllEvents, getAllPageViews } from "@/lib/sessionContractDataProvider";

  document.addEventListener("astro:page-load", async () => {
    try {
      // Update session count
      const sessionCount = await getSessionCount();
      const sessionCountElement = document.getElementById("sessionCount");
      if (sessionCountElement && sessionCount !== null) {
        sessionCountElement.textContent = sessionCount.toString();
      }

      // Update top 5 page views
      const allPageViews = await getAllPageViews();
      console.log("All Page Views: ", allPageViews); // Added for debugging
      if (Array.isArray(allPageViews) && allPageViews.length > 0 && Array.isArray(allPageViews[0])) {
        const pageOccurrences = allPageViews[0];
        const pagePaths = allPageViews[1];
        if (pageOccurrences && pagePaths && pageOccurrences.length === pagePaths.length) {
          const pageViewCounts = pageOccurrences
            .map((views, i) => ({ page: pagePaths[i], views }))
            .sort((a, b) => b.views - a.views)
            .slice(0, 5);

          console.log("Page View Counts: ", pageViewCounts); // Added for debugging
          pageViewCounts.forEach((pageView, i) => {
            const pageElement = document.getElementById(`page${i}`);
            const viewsElement = document.getElementById(`views${i}`);
            if (pageElement) {
              pageElement.textContent = pageView.page;
            }
            if (viewsElement) {
              viewsElement.textContent = pageView.views.toString();
            }
          });
        } else {
          console.error("Mismatch between page occurrences and page paths lengths"); // Improved error handling
        }
      } else {
        console.error("Invalid data structure for page views"); // Improved error handling
      }

      // Update top 3 events
      const allEvents = await getAllEvents();
      console.log("All Events: ", allEvents); // Added for debugging
      if (Array.isArray(allEvents) && allEvents.length > 0 && Array.isArray(allEvents[0])) {
        const eventOccurrences = allEvents[0];
        const eventNames = allEvents[1];
        if (eventOccurrences && eventNames && eventOccurrences.length === eventNames.length) {
          const eventCounts = eventOccurrences
            .map((count, i) => ({ event: eventNames[i], count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 3);

          console.log("Event Counts: ", eventCounts); // Added for debugging
          eventCounts.forEach((event, i) => {
            const eventElement = document.getElementById(`event${i}`);
            const countElement = document.getElementById(`count${i}`);
            if (eventElement) {
              eventElement.textContent = event.event;
            }
            if (countElement) {
              countElement.textContent = event.count.toString();
            }
          });
        } else {
          console.error("Mismatch between event occurrences and event names lengths"); // Improved error handling
        }
      } else {
        console.error("Invalid data structure for events"); // Improved error handling
      }

      // Update session IDs
      const sessionIds = await getAllSessionIds();
      const sessionIDsContainer = document.getElementById("sessionIDs");
      if (sessionIDsContainer && Array.isArray(sessionIds)) {
        sessionIds.forEach((sessionId) => {
          const span = document.createElement("span");
          span.textContent = sessionId;
          span.classList.add("sessionHash");
          sessionIDsContainer.appendChild(span);
        });
      }
    } catch (error) {
      console.error("An error occurred while fetching data: ", error);
    }
  });
</script>
