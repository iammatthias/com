---
import Layout from "@layouts/layout.astro";
import { getObsidianEntries } from "@lib/github";
import Image from "@components/img.astro";
import Paragraph from "@components/paragraph.astro";
import BreadCrumb from "@components/breadcrumb.astro";
import Meta_ReadTime_Dates from "@components/meta_readtime_dates.astro";
import Meta_Tags from "@components/meta_tags.astro";
import Squiggle from "@components/squiggle.astro";

import { Markdown } from "astro-remote";
import { markedHighlight } from "marked-highlight";
import markedAlert from "marked-alert";
// import hljs from "highlight.js";

export async function getStaticPaths() {
  const categories = ["posts", "recipes", "notes", "art"];
  let staticPaths: { params: { path: string; slug: string } }[] = [];

  // Iterate over each category to fetch entries
  for (const path of categories) {
    const entries = await getObsidianEntries(path);
    // Add paths for each entry's slug under the current path
    entries.forEach((entry) => {
      if (entry.frontmatter.slug) {
        // Ensure there is a slug before adding to paths

        staticPaths.push({
          params: { path, slug: entry.frontmatter.slug },
        });
      }
    });
  }

  return staticPaths;
}

// Parameters are received from the URL defined by the static paths
const { path, slug } = Astro.params;
const entries = await getObsidianEntries(path, slug); // Directly use path and slug to get the entry
const entry = entries[0]; // Assuming getObsidianEntries returns an array with one entry when slug is provided

if (!entry) {
  throw new Error("404: Entry not found");
}

const { body, frontmatter } = entry;
const readingTime = Math.ceil(body.split(/\s+/).length / 180);
---

<Layout title={frontmatter.title} path={path}>
  <main>
    <BreadCrumb path={path} />
    <h1>{frontmatter.title}</h1>
    <div class='meta'>
      <Meta_ReadTime_Dates created={frontmatter.created} updated={frontmatter.updated} readingTime={readingTime} />
      <Meta_Tags tags={frontmatter.tags} />
    </div>
    <Squiggle />
    <article>
      <Markdown
        sanitize={{ allowComponents: true }}
        content={body}
        components={{ img: Image, p: Paragraph }}
        marked={{
          extensions: [
            // markedHighlight({
            //   highlight(code, lang) {
            //     const language = hljs.getLanguage(lang) ? lang : "plaintext";
            //     return hljs.highlight(code, { language }).value;
            //   },
            // }) as any,
            markedAlert(),
          ],
        }}
      />
    </article>
    <BreadCrumb path={path} />
  </main>
</Layout>

<style>
  article {
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  article:has(.masonry) {
    max-width: unset;
    grid-gap: 2rem;
  }

  /* Extra small devices (portrait phones, less than 576px) */
  @media (max-width: 575px) {
    article:has(.masonry) {
      max-width: unset;
      grid-gap: 1rem;
    }
  }

  .meta {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
</style>
