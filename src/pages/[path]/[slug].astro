---
import Layout from "@layouts/layout.astro";
import { getObsidianEntries } from "@lib/github";
import Image from "@components/img.astro";
import Paragraph from "@components/paragraph.astro";

import { Markdown } from "astro-remote";
import { markedHighlight } from "marked-highlight";
import markedAlert from "marked-alert";
import hljs from "highlight.js";

const { path, slug } = Astro.params;

const paths = ["art", "posts", "recipes", "notes" /* add other content types here */];

if (!path || !paths.includes(path)) {
  return (
    {
      status: 404,
      error: "Content type not found",
    },
    Astro.redirect("/404")
  );
}

const entry = await getObsidianEntries(path, slug);

if (!entry) {
  return (
    {
      status: 404,
      error: "Entry not found",
    },
    Astro.redirect("/404")
  );
}

if (!entry || (process.env.NODE_ENV === "production" && entry[0].frontmatter.published === false)) {
  return (
    {
      status: 404,
      error: "Entry not found",
    },
    Astro.redirect("/404")
  );
}

if (!entry) {
  return (
    {
      status: 404,
      error: "Entry not found",
    },
    Astro.redirect("/404")
  );
}

const { body, frontmatter } = entry[0];

// Convert the timestamps to Date objects
const createdAtDate = new Date(frontmatter.created);
const updatedAtDate = new Date(frontmatter.updated);

// Calculate the difference in milliseconds
const difference = updatedAtDate.getTime() - createdAtDate.getTime();

// Check if the difference is more than 24 hours
const isUpdatedAfter24Hours = difference > 24 * 60 * 60 * 1000;
---

<Layout title={`${frontmatter.title} | ${path.charAt(0).toUpperCase() + path.slice(1)}`}>
  <main>
    <div class='meta'>
      <p><small><a href={`/${path}`}>« View more</a></small></p>
      <h1>{frontmatter.title}</h1>
      <p>
        <small>
          This post was first published at <time datetime={frontmatter.created}>{frontmatter.created}</time>. {
            isUpdatedAfter24Hours && (
              <time datetime={frontmatter.updated}>It was last updated at {frontmatter.updated}</time>
            )
          }
        </small>
      </p>

      <p>
        <small>
          Estimated reading time: <span id='readingTime'></span>
        </small>
      </p>

      {
        frontmatter.tags && frontmatter.tags.length > 0 && (
          <div class='tags'>
            {frontmatter.tags.map((tag: string) => (
              <span>
                <small>
                  <a href={`/tags/${tag}`}>#{tag}</a>
                </small>
              </span>
            ))}
          </div>
        )
      }
    </div>
    <article>
      <Markdown
        sanitize={{ allowComponents: true }}
        content={body}
        components={{ img: Image, p: Paragraph }}
        marked={{
          extensions: [
            markedHighlight({
              highlight(code, lang, info) {
                const language = hljs.getLanguage(lang) ? lang : "plaintext";
                return hljs.highlight(code, { language }).value;
              },
            }) as any,
            markedAlert(),
          ],
        }}
      />
    </article>
    <p><small><a href={`/${path}`}>« View more</a></small></p>
  </main>
</Layout>

<script>
  function getReadingTime() {
    const text = document.querySelector("article")!.innerText;
    const wpm = 225;
    const words = text.trim().split(/\s+/).length;
    const time = Math.ceil(words / wpm);
    const timeText = time > 1 ? `${time} minutes` : `${time} minute`;
    document.getElementById("readingTime")!.innerText = timeText;
  }
  getReadingTime();
</script>

<style>
  article {
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  article:has(.masonry) {
    max-width: unset;
    grid-gap: 2rem;
  }

  /* Extra small devices (portrait phones, less than 576px) */
  @media (max-width: 575px) {
    article:has(.masonry) {
      max-width: unset;
      grid-gap: 1rem;
    }
  }

  .tags {
    display: flex;
    gap: 0.5rem;
  }
</style>

<style is:global>
  .markdown-alert {
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--alert-border-color);
    display: flex;
    gap: 1rem;
    flex-direction: column;
    color: var(--alert-text-color);
    box-shadow: var(--smooth-shadow);
  }

  .markdown-alert svg {
    width: 1rem;
    height: auto;
    fill: currentColor;
    display: inline-block;
    margin-right: 1rem;
    margin-bottom: 0.2rem;
    vertical-align: middle;
  }

  .markdown-alert-note {
    background-color: var(--alert-note-bg);
  }

  .markdown-alert-tip {
    background-color: var(--alert-tip-bg);
  }

  .markdown-alert-important {
    background-color: var(--alert-important-bg);
  }

  .markdown-alert-warning {
    background-color: var(--alert-warning-bg);
  }

  .markdown-alert-caution {
    background-color: var(--alert-caution-bg);
  }
</style>
