---
const { src, alt, priority = false } = Astro.props;

// Extract the CID from the URL
const extractCid = (url: string) => {
  if (!url) {
    console.error("[Img.astro] No URL provided");
    return null;
  }

  // Remove any wsrv references
  let cleanUrl = url.replace("https://wsrv.nl/?url=", "");

  // Handle ipfs:// protocol
  if (cleanUrl.startsWith("ipfs://")) {
    const cid = cleanUrl.replace("ipfs://", "");
    return cid;
  }

  // Remove any query parameters
  cleanUrl = cleanUrl.replace(/\?.*$/, "");

  // If it's already a CID, return it
  if (cleanUrl.startsWith("Qm") || cleanUrl.startsWith("baf")) {
    return cleanUrl;
  }

  // If it's a full IPFS URL, extract the CID
  const ipfsMatch = cleanUrl.match(/\/ipfs\/([^/]+)/);
  if (ipfsMatch) {
    return ipfsMatch[1];
  }

  console.error("[Img.astro] Could not extract CID from URL:", url);
  return null;
};

// Convert CID to gateway URL
const getGatewayUrl = (cid: string) => {
  return `https://silver-bitter-junglefowl-364.mypinata.cloud/ipfs/${cid}`;
};

const cid = extractCid(src);

if (!cid) {
  console.error("[Img.astro] Invalid image source:", src);
}

// Get the gateway URL for the image
const gatewayUrl = cid ? getGatewayUrl(cid) : "";
---

<div class='image-container' data-cid={cid}>
  <div class='placeholder'>
    <svg width='100' height='100' viewBox='0 0 100 100' fill='none' xmlns='http://www.w3.org/2000/svg'>
      <rect width='100' height='100' fill='#F3F4F6'></rect>
      <path
        d='M50 30C44.4772 30 40 34.4772 40 40C40 45.5228 44.4772 50 50 50C55.5228 50 60 45.5228 60 40C60 34.4772 55.5228 30 50 30ZM50 45C47.2386 45 45 42.7614 45 40C45 37.2386 47.2386 35 50 35C52.7614 35 55 37.2386 55 40C55 42.7614 52.7614 45 50 45Z'
        fill='#9CA3AF'></path>
      <path
        d='M65 65H35C32.2386 65 30 67.2386 30 70V75C30 77.7614 32.2386 80 35 80H65C67.7614 80 70 77.7614 70 75V70C70 67.2386 67.7614 65 65 65ZM65 75H35V70H65V75Z'
        fill='#9CA3AF'></path>
    </svg>
  </div>
  <img
    src={priority ? gatewayUrl : ""}
    alt={alt}
    loading={priority ? "eager" : "lazy"}
    class='responsive-image'
    data-cid={cid}
    data-gateway-url={gatewayUrl}
  />
</div>

<style>
  .image-container {
    position: relative;
    width: 100%;
    background-color: #f3f4f6;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    object-fit: contain;
    padding: 1rem;
  }

  .placeholder {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
  }

  .placeholder.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .responsive-image {
    width: 100%;
    height: auto;
    display: block;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }

  .responsive-image.loaded {
    opacity: 1;
  }

  .responsive-image.error {
    opacity: 0;
  }
</style>

<script>
  // Simplified image loader with viewport-based loading
  class ImageLoader {
    private observer: IntersectionObserver;
    private loadedImages = new Set<string>();
    private loadingImages = new Set<string>();
    private retryCount = new Map<string, number>();
    private maxRetries = 2;

    constructor() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const img = entry.target as HTMLImageElement;
              const cid = img.dataset.cid;
              if (cid && !this.loadedImages.has(cid) && !this.loadingImages.has(cid)) {
                this.loadImage(img, cid);
              }
            }
          });
        },
        {
          rootMargin: "100% 0px", // Load images when they're one viewport height away
          threshold: 0.1,
        }
      );
    }

    async loadImage(img: HTMLImageElement, cid: string) {
      if (this.loadingImages.has(cid)) return;
      this.loadingImages.add(cid);

      const container = img.closest(".image-container");
      const placeholder = container?.querySelector(".placeholder");
      if (!container || !placeholder) return;

      const gatewayUrl = img.dataset.gatewayUrl;
      if (!gatewayUrl) {
        console.error("[ImageLoader] No gateway URL found for CID:", cid);
        this.loadingImages.delete(cid);
        return;
      }

      try {
        // Create a new image to test loading
        const testImage = new Image();
        testImage.onload = () => {
          img.src = gatewayUrl;
          img.classList.add("loaded");
          placeholder.classList.add("hidden");
          this.loadedImages.add(cid);
          this.loadingImages.delete(cid);
        };
        testImage.onerror = () => {
          this.handleError(img, cid, placeholder);
        };
        testImage.src = gatewayUrl;
      } catch (error) {
        console.error("[ImageLoader] Error loading image:", error);
        this.handleError(img, cid, placeholder);
      }
    }

    private handleError(img: HTMLImageElement, cid: string, placeholder: Element) {
      const retries = this.retryCount.get(cid) || 0;
      if (retries < this.maxRetries) {
        this.retryCount.set(cid, retries + 1);
        setTimeout(
          () => {
            this.loadingImages.delete(cid);
            this.loadImage(img, cid);
          },
          Math.pow(2, retries) * 1000
        ); // Exponential backoff
      } else {
        img.classList.add("error");
        placeholder.classList.remove("hidden");
        this.loadingImages.delete(cid);
        console.error("[ImageLoader] Failed to load image after retries:", cid);
      }
    }

    observe(img: HTMLImageElement) {
      this.observer.observe(img);
    }

    unobserve(img: HTMLImageElement) {
      this.observer.unobserve(img);
    }

    destroy() {
      this.observer.disconnect();
    }
  }

  // Initialize the loader
  const imageLoader = new ImageLoader();

  // Handle view transitions
  document.addEventListener("astro:page-load", () => {
    // Reset state for new page
    const images = document.querySelectorAll("img[data-cid]");
    images.forEach((img) => {
      if (img instanceof HTMLImageElement) {
        imageLoader.observe(img);
      }
    });
  });

  document.addEventListener("astro:before-preparation", () => {
    // Clean up before navigation
    const images = document.querySelectorAll("img[data-cid]");
    images.forEach((img) => {
      if (img instanceof HTMLImageElement) {
        imageLoader.unobserve(img);
      }
    });
    imageLoader.destroy();
  });

  // Initial load
  document.querySelectorAll("img[data-cid]").forEach((img) => {
    if (img instanceof HTMLImageElement) {
      if (img.getAttribute("loading") === "eager") {
        const cid = img.dataset.cid;
        if (cid) {
          imageLoader.loadImage(img, cid);
        }
      } else {
        imageLoader.observe(img);
      }
    }
  });
</script>
