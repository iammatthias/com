---
// export const prerender = true;

import Layout from "@layouts/layout.astro";
import Squiggle from "@components/squiggle.astro";
---

<Layout title='Onchain Analytics'>
  <main>
    <h1>Onchain Analytics</h1>
    <p>
      This site features onchain analytics to track sessions and page counts. If you're interested, you can read more
      about the project here: <a class='break' href='https://iammatthias.com/posts/1712329304675-onchain-hit-counter'
        >iammatthias.com/posts/1712329304675-onchain-hit-counter</a
      >.
    </p>
    <Squiggle />

    <h3>How it Works:</h3>
    <ul>
      <li>
        The client IP, user agent, and timestamp are hashed (keccak256) client-side to generate a unique, irreversible
        <code>sessionID</code>. Only the hash is stored.
      </li>
      <li><code>sessionID</code>s are stored onchain to validate page views without any personal data.</li>
      <li>Page views are counted using a simple incrementing integer attached to each page path.</li>
      <li>
        All onchain interactions are handled by a [syndicate.io](Syndicate.io) `Cloud Transaction` wallet in the
        background.
      </li>
    </ul>

    <h3>Data Collection Details:</h3>
    <p>
      Data collection began at <a
        href='https://sepolia.basescan.org/tx/0x8364d0d8827f5129965955c0e836cb54af213dc0aaa43e7b53635f3ced43135f'
        >block number 8853154 on Base-Sepolia</a
      >. The contract is verified on BaseScan: <a
        class='break'
        href='https://sepolia.basescan.org/address/0x40d59f33d1e36d8ddc171af7c40bd85ca25008f0#code#L1'
        >0x40d59f33D1e36D8DDC171Af7C40Bd85Ca25008F0</a
      >.
    </p>

    <h3>Analytics Data:</h3>
    <p>Total site views: <span id='sessionCount'></span></p>
    <p>Top pages by view count:</p>
    <div id='pageCounts'></div>
    <h4>Session IDs:</h4>
    <div id='sessionIDs'>
      <!-- Dynamically filled spans for each session ID -->
    </div>
  </main>
</Layout>

<script>
  import { publicClient } from "@lib/viemClients";
  import { sessionCountABI, getAllPageViewsABI, getAllSessionHashesABI } from "@lib/abi";

  const contractAddress = await import.meta.env.PUBLIC_HIT_COUNTER_CONTRACT;
  const topPagesCount = 5; // Adjust this value as needed

  // Function to safely update text content of an element
  function safelyUpdateTextContent(id, text) {
    const element = document.getElementById(id);
    if (element) {
      element.innerText = text;
    } else {
      console.error(`Element with id '${id}' not found.`);
    }
  }

  // Function to show loading indicators
  function showLoadingIndicator(id) {
    const element = document.getElementById(id);
    if (element) {
      element.innerHTML = '<div class="loading">Loading...</div>'; // Simple text or replace with an HTML/CSS spinner
    }
  }

  // Function to hide loading indicators
  function hideLoadingIndicator(id) {
    const element = document.getElementById(id);
    const loadingElement = element?.querySelector(".loading");
    if (element && loadingElement) {
      element.removeChild(loadingElement);
    }
  }

  // Async function to update session count
  async function updateSessionCount() {
    showLoadingIndicator("sessionCount");
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: sessionCountABI,
        functionName: "sessionCount",
      });
      safelyUpdateTextContent("sessionCount", `${Number(data)}`);
    } catch (error) {
      console.error("Failed to fetch session count:", error);
      safelyUpdateTextContent("sessionCount", "Failed to load data.");
    }
    hideLoadingIndicator("sessionCount");
  }

  // Async function to update page counts
  async function updatePageCounts() {
    const pagesTable = document.getElementById("pageCounts"); // Define pagesTable here
    showLoadingIndicator("pageCounts");
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllPageViewsABI,
        functionName: "getAllPageViews",
      });

      if (pagesTable) {
        let tableHTML = "<table><tr><th>Page</th><th>Views</th></tr>";
        const pageData = data[0].map((page, index) => ({
          page: page,
          count: BigInt(data[1][index]),
        }));
        pageData.sort((a, b) => (b.count > a.count ? 1 : -1));
        pageData.slice(0, topPagesCount).forEach((item) => {
          tableHTML += `<tr><td><a href="${item.page}">${item.page}</a></td><td>${item.count.toString()}</td></tr>`;
        });
        tableHTML += "</table>";
        pagesTable.innerHTML = tableHTML;
      } else {
        console.error("Element with id 'pageCounts' not found.");
      }
    } catch (error) {
      console.error("Failed to fetch page counts:", error);
      if (pagesTable) {
        pagesTable.innerHTML = "<p>Failed to load page counts.</p>"; // Provide a fallback message within the table
      }
    }
    hideLoadingIndicator("pageCounts");
  }

  // Async function to update session IDs
  async function updateSessionIDs() {
    const sessionIDs = document.getElementById("sessionIDs"); // Define sessionIDs here
    showLoadingIndicator("sessionIDs");
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllSessionHashesABI,
        functionName: "getAllSessionHashes",
      });

      if (sessionIDs) {
        sessionIDs.innerHTML = ""; // Clear previous content
        data.forEach((hash) => {
          const hashSpan = document.createElement("span");
          hashSpan.className = "sessionHash";
          hashSpan.innerText = hash;
          sessionIDs.appendChild(hashSpan);
          sessionIDs.appendChild(document.createTextNode(" ")); // Space for readability
        });
      } else {
        console.error("Element with id 'sessionIDs' not found.");
      }
    } catch (error) {
      console.error("Failed to fetch session IDs:", error);
      if (sessionIDs) {
        sessionIDs.innerHTML = "<p>Failed to load session IDs.</p>"; // Provide a fallback message
      }
    }
    hideLoadingIndicator("sessionIDs");
  }

  // Initialize data on page load
  window.addEventListener("load", () => {
    updateSessionCount();
    updatePageCounts();
    updateSessionIDs();
  });

  // Watch for new blocks and update data
  const watchDataUpdates = () => {
    const unwatch = publicClient.watchBlocks({
      onBlock: () => {
        updateSessionCount();
        updatePageCounts();
        updateSessionIDs();
      },
      onError: (error) => console.error("Error watching blocks:", error),
    });

    window.addEventListener("unload", unwatch);
  };

  watchDataUpdates();
</script>

<style is:global>
  main * {
    font-family: monospace; /* Monospace font for fixed-width display */
  }
  p,
  li,
  span {
    font-size: var(--fs-sm);
  }

  a,
  th,
  td {
    font-size: 0.9rem;
  }

  #sessionIDs {
    white-space: normal; /* Ensures the normal text wrapping and white-space handling */
  }

  .sessionHash {
    display: inline; /* Keeps span inline */
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
    margin-right: 0.5rem; /* Adds horizontal space between items */
    transition:
      background-color 0.3s ease,
      color 0.3s ease; /* Smooth transition for background and text color */
  }

  .sessionHash:hover {
    background-color: var(--gold); /* Light grey background on hover */
  }

  .break {
    overflow-wrap: break-word; /* Handles normal wrapping */
    word-break: break-all; /* Forces break for long unbreakable strings */
  }

  .loading {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 50px; /* Ensure adequate space for the spinner or text */
  }
</style>
