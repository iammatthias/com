---
// export const prerender = true;

import Layout from "@layouts/layout.astro";
import Squiggle from "@components/squiggle.astro";
---

<Layout title='Onchain Analytics'>
  <main>
    <h1>Onchain Analytics</h1>
    <p>
      This site features onchain analytics to track sessions and page counts. If you're interested, you can read more
      about the project here: <a href='https://iammatthias.com/posts/1712329304675-onchain-hit-counter'
        >iammatthias.com/posts/1712329304675-onchain-hit-counter</a
      >.
    </p>
    <Squiggle />

    <section>
      <h3>How it Works:</h3>
      <ul>
        <li>
          Your IP, user agent, and timestamp are hashed (keccak256) client-side to generate a unique, irreversible
          session ID.
        </li>
        <li>Session IDs are stored onchain to validate page views without any personal data.</li>
        <li>Page views are counted using a simple incrementing integer attached to each page path.</li>
      </ul>
    </section>

    <section>
      <h3>Data Collection Details:</h3>
      <p>
        Data collection began at <a
          href='https://sepolia.basescan.org/tx/0x8364d0d8827f5129965955c0e836cb54af213dc0aaa43e7b53635f3ced43135f'
          >block number 8853154 on Base-Sepolia</a
        >. The contract is verified on BaseScan: <a
          href='https://sepolia.basescan.org/address/0x40d59f33d1e36d8ddc171af7c40bd85ca25008f0#code#L1'
          >0x40d59f33D1e36D8DDC171Af7C40Bd85Ca25008F0</a
        >.
      </p>
    </section>

    <section>
      <h3>Analytics Data:</h3>
      <ul>
        <li>Total site views: <span id='sessionCount'>Loading...</span></li>
        <li>
          Top pages by view count:
          <ul id='pageCounts'>
            <!-- Dynamically filled -->
          </ul>
        </li>
      </ul>
      <h4>Session IDs:</h4>
      <div id='sessionIDs'>
        <!-- Dynamically filled spans for each session ID -->
      </div>
    </section>
  </main>
</Layout>

<script>
  import { publicClient } from "@lib/viemClients";
  import { sessionCountABI, getAllPageViewsABI, getAllSessionHashesABI } from "@lib/abi";

  const contractAddress = await import.meta.env.PUBLIC_HIT_COUNTER_CONTRACT;
  const topPagesCount = 5; // Adjust this value as needed

  // Function to safely update text content of an element
  function safelyUpdateTextContent(id, text) {
    const element = document.getElementById(id);
    if (element) {
      element.innerText = text;
    } else {
      console.error(`Element with id '${id}' not found.`);
    }
  }

  // Async function to update session count
  async function updateSessionCount() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: sessionCountABI,
        functionName: "sessionCount",
      });
      safelyUpdateTextContent("sessionCount", `${Number(data)}`);
    } catch (error) {
      console.error("Failed to fetch session count:", error);
    }
  }

  // Async function to update page counts
  async function updatePageCounts() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllPageViewsABI,
        functionName: "getAllPageViews",
      });

      const pagesList = document.getElementById("pageCounts");
      if (pagesList) {
        pagesList.innerHTML = ""; // Clear existing list

        // Ensure data[1] which contains counts is treated as BigInt for sorting and comparison
        const pageData = data[0].map((page, index) => ({
          page: page,
          count: BigInt(data[1][index]), // Treat count as BigInt
        }));

        // Sort by count using BigInt comparison
        pageData.sort((a, b) => (b.count > a.count ? 1 : b.count < a.count ? -1 : 0));

        // Slice to topPagesCount and append to DOM
        pageData.slice(0, topPagesCount).forEach((item) => {
          const pageElement = document.createElement("li");
          pageElement.innerText = `${item.page} (${item.count.toString()})`; // Convert BigInt to string for display
          pagesList.appendChild(pageElement);
        });
      } else {
        console.error("Element with id 'pageCounts' not found.");
      }
    } catch (error) {
      console.error("Failed to fetch page counts:", error);
    }
  }

  // Async function to update session IDs
  async function updateSessionIDs() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllSessionHashesABI,
        functionName: "getAllSessionHashes",
      });

      const sessionIDs = document.getElementById("sessionIDs");
      if (sessionIDs) {
        sessionIDs.innerHTML = "";
        data.forEach((hash) => {
          const hashSpan = document.createElement("span");
          hashSpan.className = "session-hash";
          hashSpan.innerText = hash;
          sessionIDs.appendChild(hashSpan);
          sessionIDs.appendChild(document.createTextNode(" ")); // Space for readability
        });
      } else {
        console.error("Element with id 'sessionIDs' not found.");
      }
    } catch (error) {
      console.error("Failed to fetch session IDs:", error);
    }
  }

  // Initialize data on page load
  window.addEventListener("load", () => {
    updateSessionCount();
    updatePageCounts();
    updateSessionIDs();
  });

  // Watch for new blocks and update data
  const watchDataUpdates = () => {
    const unwatch = publicClient.watchBlocks({
      onBlock: () => {
        updateSessionCount();
        updatePageCounts();
        updateSessionIDs();
      },
      onError: (error) => console.error("Error watching blocks:", error),
    });

    window.addEventListener("unload", unwatch);
  };

  watchDataUpdates();
</script>
