---
import Layout from "@layouts/layout.astro";
import Squiggle from "@components/squiggle.astro";
---

<Layout path='Onchain Analytics'>
  <main class='text'>
    <h1>Onchain Analytics</h1>
    <p>
      This site features onchain analytics to track sessions and page counts. If you're interested, you can read more
      about the project here: <a class='break' href='https://iammatthias.com/posts/1712329304675-onchain-hit-counter'
        >iammatthias.com/posts/1712329304675-onchain-hit-counter</a
      >.
    </p>
    <Squiggle />

    <h3>How it Works:</h3>
    <ul>
      <li>
        The client IP, user agent, and timestamp are hashed (keccak256) client-side to generate a unique, irreversible
        <code>sessionID</code>. Only the hash is stored.
      </li>
      <li><code>sessionID</code>s are stored onchain to validate page views without any personal data.</li>
      <li>Page views are counted using a simple incrementing integer attached to each page path.</li>
      <li>
        All onchain interactions are handled by a [syndicate.io](Syndicate.io) `Cloud Transaction` wallet in the
        background.
      </li>
    </ul>

    <h3>Data Collection Details:</h3>
    <p>
      Data collection began at <a
        href='https://sepolia.basescan.org/tx/0x8364d0d8827f5129965955c0e836cb54af213dc0aaa43e7b53635f3ced43135f'
        >block number 8853154 on Base-Sepolia</a
      >. The contract is verified on BaseScan: <a
        class='break'
        href='https://sepolia.basescan.org/address/0x40d59f33d1e36d8ddc171af7c40bd85ca25008f0#code#L1'
        >0x40d59f33D1e36D8DDC171Af7C40Bd85Ca25008F0</a
      >.
    </p>

    <h3>Analytics Data:</h3>
    <p>Total site views: <span id='sessionCount'></span></p>
    <p>Top pages by view count:</p>

    <table id='pageCounts'>
      <tr><th>Page</th><th>Views</th></tr>
      <!-- Placeholder rows for dynamic content -->
      {
        Array.from({ length: 5 }).map((_, i) => (
          <tr>
            <>
              <td id={`page${i}`} />
              <td id={`views${i}`} />
            </>
          </tr>
        ))
      }
    </table>

    <h4>Session IDs:</h4>
    <div id='sessionIDs'>
      <!-- Dynamically filled spans for each session ID -->
    </div>
  </main>
</Layout>

<!-- <script src='../../lib/analytics.ts'></script> -->

<script>
  import { publicClient } from "@lib/viemClients";
  import { sessionCountABI, getAllPageViewsABI, getAllSessionHashesABI } from "@lib/abi";

  const contractAddress = await import.meta.env.PUBLIC_HIT_COUNTER_CONTRACT;

  function safelyUpdateTextContent(id, text) {
    const element = document.getElementById(id);
    if (element) {
      element.innerText = text;
      return true;
    }
    console.error(`Element with id '${id}' not found.`);
    return false;
  }

  async function updateSessionCount() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: sessionCountABI,
        functionName: "sessionCount",
      });
      safelyUpdateTextContent("sessionCount", `${Number(data)}`);
    } catch (error) {
      console.error("Failed to fetch session count:", error);
    }
  }

  async function updatePageCounts() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllPageViewsABI,
        functionName: "getAllPageViews",
      });
      const pageData = data[0].map((page, index) => ({
        page: page,
        count: BigInt(data[1][index]),
      }));
      pageData.sort((a, b) => (a.count > b.count ? -1 : a.count < b.count ? 1 : 0));
      pageData.forEach((item, index) => {
        if (index < 5) {
          safelyUpdateTextContent(`page${index}`, item.page);
          safelyUpdateTextContent(`views${index}`, item.count.toString());
        }
      });
    } catch (error) {
      console.error("Failed to fetch page counts:", error);
    }
  }

  async function updateSessionIDs() {
    try {
      const data = await publicClient.readContract({
        address: contractAddress,
        abi: getAllSessionHashesABI,
        functionName: "getAllSessionHashes",
      });
      const sessionIDs = document.getElementById("sessionIDs")!;
      sessionIDs.innerHTML = ""; // Clear previous entries
      data.reverse(); // Show the latest session IDs first
      data.forEach((hash) => {
        const hashSpan = document.createElement("span");
        hashSpan.className = "sessionHash";
        hashSpan.innerText = hash;

        const hashLink = document.createElement("a");
        hashLink.href = `/onchain-analytics/${hash}`;
        hashLink.appendChild(hashSpan);

        sessionIDs.appendChild(hashLink);
        sessionIDs.appendChild(document.createTextNode(" "));
      });
    } catch (error) {
      console.error("Failed to fetch session IDs:", error);
    }
  }

  document.addEventListener(
    "astro:page-load",
    async () => {
      // Execute all async operations in parallel
      await Promise.all([updateSessionCount(), updatePageCounts(), updateSessionIDs()]).catch((error) => {
        console.error("Error updating data:", error);
      });
    },
    { once: true }
  );

  const unwatch = publicClient.watchBlocks({
    onBlock: async () => {
      await Promise.all([updateSessionCount(), updatePageCounts(), updateSessionIDs()]).catch((error) =>
        console.error("Error watching blocks:", error)
      );
    },
    onError: (error) => console.error("Error watching blocks:", error),
  });

  window.addEventListener("unload", unwatch);
</script>

<style>
  .text {
    font-size: var(--fs-sm);
  }

  .text th,
  .text td {
    font-family: monospace;
    font-size: 0.9rem;
  }

  .text td {
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
  }

  #sessionIDs {
    white-space: normal; /* Ensures the normal text wrapping and white-space handling */
  }
</style>

<style is:global>
  .sessionHash {
    font-family: monospace;
    display: inline; /* Keeps span inline */
    word-break: break-all; /* Breaks long words anywhere */
    white-space: normal; /* Allows wrapping */
    margin-right: 0.5rem; /* Adds horizontal space between items */
    transition:
      background-color 0.3s ease,
      color 0.3s ease; /* Smooth transition for background and text color */
  }

  .sessionHash:hover {
    background-color: var(--gold); /* Light grey background on hover */
  }

  .break {
    overflow-wrap: break-word; /* Handles normal wrapping */
    word-break: break-all; /* Forces break for long unbreakable strings */
  }
</style>
